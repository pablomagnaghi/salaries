// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package auth

import (
	"github.com/gin-gonic/gin"
	"salaries/pkg/domain"
	"sync"
)

// Ensure, that ServiceMock does implement Service.
// If this is not the case, regenerate this file with moq.
var _ Service = &ServiceMock{}

// ServiceMock is a mock implementation of Service.
//
//	func TestSomethingThatUsesService(t *testing.T) {
//
//		// make and configure a mocked Service
//		mockedService := &ServiceMock{
//			GenerateJWTFunc: func(user *domain.User) (string, error) {
//				panic("mock out the GenerateJWT method")
//			},
//			VerifyTokenFunc: func(context *gin.Context) error {
//				panic("mock out the VerifyToken method")
//			},
//		}
//
//		// use mockedService in code that requires Service
//		// and then make assertions.
//
//	}
type ServiceMock struct {
	// GenerateJWTFunc mocks the GenerateJWT method.
	GenerateJWTFunc func(user *domain.User) (string, error)

	// VerifyTokenFunc mocks the VerifyToken method.
	VerifyTokenFunc func(context *gin.Context) error

	// calls tracks calls to the methods.
	calls struct {
		// GenerateJWT holds details about calls to the GenerateJWT method.
		GenerateJWT []struct {
			// User is the user argument value.
			User *domain.User
		}
		// VerifyToken holds details about calls to the VerifyToken method.
		VerifyToken []struct {
			// Context is the context argument value.
			Context *gin.Context
		}
	}
	lockGenerateJWT sync.RWMutex
	lockVerifyToken sync.RWMutex
}

// GenerateJWT calls GenerateJWTFunc.
func (mock *ServiceMock) GenerateJWT(user *domain.User) (string, error) {
	if mock.GenerateJWTFunc == nil {
		panic("ServiceMock.GenerateJWTFunc: method is nil but Service.GenerateJWT was just called")
	}
	callInfo := struct {
		User *domain.User
	}{
		User: user,
	}
	mock.lockGenerateJWT.Lock()
	mock.calls.GenerateJWT = append(mock.calls.GenerateJWT, callInfo)
	mock.lockGenerateJWT.Unlock()
	return mock.GenerateJWTFunc(user)
}

// GenerateJWTCalls gets all the calls that were made to GenerateJWT.
// Check the length with:
//
//	len(mockedService.GenerateJWTCalls())
func (mock *ServiceMock) GenerateJWTCalls() []struct {
	User *domain.User
} {
	var calls []struct {
		User *domain.User
	}
	mock.lockGenerateJWT.RLock()
	calls = mock.calls.GenerateJWT
	mock.lockGenerateJWT.RUnlock()
	return calls
}

// VerifyToken calls VerifyTokenFunc.
func (mock *ServiceMock) VerifyToken(context *gin.Context) error {
	if mock.VerifyTokenFunc == nil {
		panic("ServiceMock.VerifyTokenFunc: method is nil but Service.VerifyToken was just called")
	}
	callInfo := struct {
		Context *gin.Context
	}{
		Context: context,
	}
	mock.lockVerifyToken.Lock()
	mock.calls.VerifyToken = append(mock.calls.VerifyToken, callInfo)
	mock.lockVerifyToken.Unlock()
	return mock.VerifyTokenFunc(context)
}

// VerifyTokenCalls gets all the calls that were made to VerifyToken.
// Check the length with:
//
//	len(mockedService.VerifyTokenCalls())
func (mock *ServiceMock) VerifyTokenCalls() []struct {
	Context *gin.Context
} {
	var calls []struct {
		Context *gin.Context
	}
	mock.lockVerifyToken.RLock()
	calls = mock.calls.VerifyToken
	mock.lockVerifyToken.RUnlock()
	return calls
}
